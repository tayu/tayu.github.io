<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja-JP" xml:lang="ja-JP"><head><meta http-equiv="content-type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width,initial-scale=1.0," /><link rel="stylesheet" type="text/css" href="main.css" /><link rel="shortcut icon" href="favicon.ico" /><title>wiliki2html</title
></head
><body><h2>WiLiKi 記法から html への変換スクリプト
</h2>
<hr>
<h3>スクリプト
</h3>
<p>キーは
</p>
<pre> (srl:sxml-&gt;html (wiliki-parse iport))
</pre>
<p>の呼び出し。ファイルあるいは文字列の入力から
html 形式が得られる。
</p>
<p>あとは前後にちょっと足して html としての体裁を整えるだけ。
</p>
<p>で、スクリプトの全体は以下
</p>
<pre>#!/usr/bin/env gosh
;; -*- coding: utf-8 -*-

(use srfi-1)
(use text.html-lite)
(use text.tree)
(use sxml.serializer)
(use wiliki.parse)

(define (conv2html iport title)
  (display "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n")
  (display (html-doctype :type :xhtml-1.0-strict))
  (display
   (tree-&gt;string
    (html:html
     :xmlns "http://www.w3.org/1999/xhtml"
     :lang "ja-JP"
     :xml:lang "ja-JP"
     (html:head
      (html:meta
       :http-equiv "content-type"
       :content "text/html; charset=UTF-8")
      (html:meta
       :name "viewport"
       :content "width=device-width,initial-scale=1.0,")
      (html:link
       :rel "stylesheet"
       :type "text/css"
       :href "main.css")
      (html:link
       :rel "shortcut icon"
       :href "favicon.ico")
      (html:title (html-escape-string title)))
     (html:body
      (srl:sxml-&gt;html (wiliki-parse iport)))))))

(define (base-name filename)
  (define delm ".") ;; (define-constant ..) is error at here, ok at outside
  (let ((names (string-split filename delm)))
    (string-join (take names (- (length names) 1)) delm)))

(define (main args)
  (define (usage)
    (format (current-error-port)
            "Usage: ~a in-file out-file.\n" *program-name*)
    (exit 2))

  (if (null? (cdr args)) (usage))
  (if (null? (cddr args)) (usage)) ;; use /dev/stdout to display console
  (if (not (null? (cdddr args))) (usage))

  (let ((ifile (cadr args)) (ofile (caddr args)))
    (call-with-input-file ifile
      (lambda (in)
        (call-with-output-file  ofile
          (lambda (out)
            (with-output-to-port out
              (lambda ()
                (conv2html in (base-name ifile)))))))))
  0)
</pre>
<h3>使い方
</h3>
<p>使い方は usage に有るように、
</p>
<pre> $ wiliki2html.scm in.wiliki out.html
</pre>
<p>の様になる。（"$" はプロンプト。以下同様）オプションは無い。
複数のファイルを扱うなら、シェルスクリプトを書くとか make を使うとかで。
</p>
<p>ちなみに、今使っているのは以下の makefile
</p>
<pre>CV              = wiliki2html.scm
cvflags         =
wilikifiles     = index.wiliki memo.wiliki start.wiliki wiliki2html.wiliki
ofiles          = $(wilikifiles:.wiliki=.html)

all: $(ofiles)

$(ofiles): $(wilikifiles)

clean:
        rm *.html

up: update
update: commit
        git push origin master

co: commit
commit:
        git commit -m "`date +'%F-%R'`" -a


.SUFFIXES: .wiliki .html

.wiliki.html:
        $(CV) $(cvflags) $&lt; $@
</pre>
<p>wilikifiles の項にソースを並べて行く。
</p>
<pre> $ make
</pre>
<p>で html ファイルを生成する。
</p>
<p>ファイル個々の依存関係をちゃんとハンドリングできていない気もするけど。
</p>
<pre> $ make co
</pre>
<p>でコミット
</p>
<pre> $ make up
</pre>
<p>で GitHub へアップロードする。また、その前にコミットもする。
</p>
<p>新規ファイルのリポジトリへの add は手動。html のみとする。
</p>
<p>.gitignore に以下を登録しておく
</p>
<pre>makefile
*.wiliki
</pre>
<h3>補足
</h3>
<h4>処理単位
</h4>
<p>入力／出力は 1 ページ単位の扱いとなる。
</p>
<h4>制約
</h4>
<p>マクロが使えない。特に wiki の個々のエントリへのリンクの様な
機能が使えない。
</p>
<h4>元ソースの管理
</h4>
<p>.wiliki ファイルは GitHub に上げないので、.git リポジトリには
登録しない。とはいえ、ローカルでバージョン管理したい。
</p>
<p>別途 git リポジトリをつくるか、あるいは Mercurial でやるか思案中。
</p>
<h3>WiLiKi ソース
</h3>
<p>入力の例として。以前のバージョン
</p>
<pre>
'''WiLiKi 記法から html への変換スクリプト'''
----
* 変換スクリプトについて

キーは
 (srl:sxml-&gt;html (wiliki-parse iport))
の呼び出し。ファイルあるいは文字列の入力から
html 形式が得られる。

あとは前後にちょっと足して html としての体裁を整えるだけ。

で、スクリプトの全体は以下
 {{{
#!/usr/bin/env gosh
;; -*- coding: utf-8 -*-

(use srfi-1)
(use text.html-lite)

（略）

(define (main args)
  (define (usage)
    (format (current-error-port)
            "Usage: ~a in-file out-file.\n" *program-name*)
    (exit 2))

  (if (null? (cdr args)) (usage))
  (if (null? (cddr args)) (usage)) ;; use /dev/stdout to display
  (if (not (null? (cdddr args))) (usage))

  (let ((ifile (cadr args)) (ofile (caddr args)))
    (call-with-input-file ifile
      (lambda (in)
        (call-with-output-file ofile
          (lambda (out)
            (conv2html in out (fnbase ifile)))))))
  0)
 }}}

使い方は usage に有るように、
 $ wiliki2html.scm in.wiliki out.html
の様になる。（"$" はプロンプト。以下同様）オプションは無い。
複数のファイルを扱うなら、シェルスクリプトを書くとか make を使うとかで。

ちなみに、今使っているのは以下の makefile
 {{{
CV              = wiliki2html.scm
cvflags         =
wilikikkfiles     = index.wiliki memo.wiliki start.wiliki wiliki2html.wiliki
ofiles          = $(wilikifiles:.wiliki=.html)

all: $(ofiles)

（略）

.SUFFIXES: .wiliki .html

.wiliki.html:
        $(CV) $(cvflags) $&lt; $@
 }}}

wilikifiles の項にソースを並べて行く。
 $ make
で html ファイルを生成する。

ファイル個々の依存関係をちゃんとハンドリングできていない気もするけど。

 $ make co
でコミット
 $ make up
で GitHub へアップロードする。また、その前にコミットもする。


リポジトリへの add は手動。


* 補足
** text.html-lite モジュール
 (html:body (wiliki-parse iport))
の様に wiliki-parse の結果を埋め込むのは、text.html-lite の期待する
形式が違うので、うまく行かない。

なので、&lt;html&gt;&lt;head&gt; タグの部分だけ、利用している。


** 処理単位
入力／出力は 1 ページ単位の扱いとなる。

マクロが使えない。特に wiki の個々のエントリへのリンクの様な
機能が使えない。

全体を 1 つの dbm に取り込む事ができれば、この辺は
可能。
[http://practical-scheme.net/wiliki/wiliki.cgi?WiLiKi%3A%E9%9D%99%E7%9A%84HTML%E3%81%B8%E3%81%AE%E5%A4%89%E6%8F%9B 静的なページ生成]
が動けば済む話なのだが。

ちょっと詳しい人なら、サクッと作ってしまうのだろうなぁ。
</pre>
<p>"{{{" と "}}}" は効果を消すため、先頭にスペースを入れてある
</p></body
></html
>